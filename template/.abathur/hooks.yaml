# Task Hook System Configuration
#
# This file defines lifecycle hooks that execute at specific events during task and branch lifecycle.
# Hooks enable automation of workflows like auto-merging branches, validation checks, and notifications.

hooks:
  # ============================================================================
  # BRANCH COMPLETION HOOKS
  # ============================================================================

  - id: auto-merge-successful-branch
    description: "Automatically spawn merge orchestrator when all tasks in a branch succeed"
    event:
      type: on_branch_complete
      branch_type: task_branch
    conditions:
      - all_tasks_succeeded: true
        min_tasks_completed: 1
        branch_pattern: "^task/.*"
    actions:
      - type: spawn_task
        agent_type: git-worktree-merge-orchestrator
        summary: "Merge ${branch_name} into ${feature_branch}"
        description: |
          # Merge Task Branch into Feature Branch

          ## Branch Details
          - Task Branch: ${branch_name}
          - Feature Branch: ${feature_branch}
          - Total Tasks: ${total_tasks}
          - All Succeeded: ${all_succeeded}

          ## Completed Tasks
          ${completed_task_ids}

          ## Your Mission
          1. Verify all tests pass in task branch worktree
          2. Merge task branch into feature branch
          3. Run integration tests on feature branch
          4. Clean up task branch and worktree if merge succeeds

          ## Safety Checks
          - Verify no conflicts exist
          - Ensure all commits are present
          - Run post-merge validation
        priority: 8
      - type: log_message
        level: info
        message: "Branch ${branch_name} complete with ${total_tasks} tasks - spawning merge orchestrator"
    priority: 10
    enabled: true

  - id: notify-branch-failures
    description: "Spawn failure analyst when branch completes with failures"
    event:
      type: on_branch_complete
      branch_type: task_branch
    conditions:
      - all_tasks_succeeded: false
        branch_pattern: "^task/.*"
    actions:
      - type: spawn_task
        agent_type: task-failure-analyst
        summary: "Analyze failures in ${branch_name}"
        description: |
          # Branch Failure Analysis

          ## Failed Branch
          - Branch: ${branch_name}
          - Feature Branch: ${feature_branch}
          - Total Tasks: ${total_tasks}
          - Failed Tasks: ${failed_task_count}

          ## Your Mission
          1. Review failed tasks: ${failed_task_ids}
          2. Analyze root cause of failures
          3. Determine if failures are related
          4. Recommend remediation strategy:
             - Can we salvage completed work?
             - Should we retry failed tasks?
             - Is the entire branch approach flawed?
          5. Create recovery plan

          ## Recovery Options
          - Option A: Fix failed tasks and continue
          - Option B: Rollback and restart with new approach
          - Option C: Abandon branch and document learnings
        priority: 9
      - type: log_message
        level: warn
        message: "Branch ${branch_name} complete with ${failed_task_count} failures - spawning analyst"
    priority: 10
    enabled: true

  - id: feature-branch-integration-test
    description: "Run integration tests when feature branch work completes"
    event:
      type: on_branch_complete
      branch_type: feature_branch
    conditions:
      - all_tasks_succeeded: true
        branch_pattern: "^feature/.*"
        min_tasks_completed: 2
    actions:
      - type: run_script
        script_path: ./.abathur/hooks/integration_test.sh
        args: ["${branch_name}"]
      - type: log_message
        level: info
        message: "Feature ${branch_name} complete - running integration tests"
    priority: 5
    enabled: true

  # ============================================================================
  # ORCHESTRATION CHAIN HOOKS
  # ============================================================================
  # These hooks are for non-chain orchestration. When using prompt chains
  # (technical_feature_workflow.yaml), the chain executor handles step transitions.
  # Enabling these with chains causes duplicate agents.

  # Chain executor handles requirements→architect transition automatically.
  # Only enable for non-chain workflows.
  - id: spawn-architect-after-requirements
    description: "Spawn technical-architect after requirements gathering (non-chain workflows only)"
    event:
      type: post_complete
    conditions:
      - agent_type: requirements-gatherer
        task_status: completed
    actions:
      - type: log_message
        level: info
        message: "Chain executor handles requirements→architect transition for ${task_summary}"
    priority: 10
    enabled: false

  # Decomposition is handled by the chain executor via process_decomposition().
  # Only enable for non-chain workflows.
  - id: process-architect-decomposition
    description: "Process technical-architect decomposition (non-chain workflows only)"
    event:
      type: post_complete
    conditions:
      - agent_type: technical-architect
        task_status: completed
    actions:
      - type: log_message
        level: info
        message: "Decomposition processed by chain executor for ${task_summary}"
    priority: 10
    enabled: false

  # ============================================================================
  # TASK-LEVEL HOOKS
  # ============================================================================

  - id: tech-requirements-pre-ready
    description: "Validate technical requirements before marking task ready"
    event:
      type: pre_ready
    conditions:
      - agent_type: technical-requirements-specialist
        parent_agent_type: technical-architect
        min_children_spawned: 3
    actions:
      - type: run_script
        script_path: ./.abathur/hooks/validate_tech_requirements.sh
        args: ["${task_id}", "${parent_task_id}"]
      - type: log_message
        level: info
        message: "Validating requirements for task ${task_id}"
    priority: 10
    enabled: true

  - id: log-task-start
    description: "Log when high-priority tasks start execution"
    event:
      type: post_start
    conditions:
      - priority_min: 8
    actions:
      - type: log_message
        level: info
        message: "High-priority task started: ${task_summary} (${task_agent_type})"
    priority: 1
    enabled: true

  - id: log-task-completion
    description: "Log when tasks complete"
    event:
      type: post_complete
    actions:
      - type: log_message
        level: info
        message: "Task completed: ${task_summary} (status: ${task_status})"
    priority: 1
    enabled: true

  - id: spawn-validation-after-implementation
    description: "Automatically spawn validation task after implementation completes"
    event:
      type: post_complete
    conditions:
      - agent_type_pattern: "^rust-.*-specialist$"
        exclude_agent_types:
          - rust-testing-specialist
          - rust-validation-specialist
        task_status: completed
        has_metadata_key:
          - worktree_path
    actions:
      - type: spawn_task
        agent_type: rust-testing-specialist
        summary: "Validate ${task_summary}"
        description: |
          # Validation Task

          ## Implementation Details
          - Original Task: ${task_summary}
          - Agent Type: ${task_agent_type}
          - Worktree: ${worktree_path}
          - Task Branch: ${branch}
          - Feature Branch: ${feature_branch}

          ## Your Mission
          1. Navigate to worktree: ${worktree_path}
          2. Run all tests (unit, integration)
          3. Verify code quality (clippy, fmt)
          4. Ensure no regressions
          5. Report validation results

          ## Success Criteria
          - All tests pass
          - No clippy warnings
          - Code properly formatted
        priority: 4
      - type: log_message
        level: info
        message: "Implementation complete - spawning validation for ${task_summary}"
    priority: 9
    enabled: true

  # ============================================================================
  # VALIDATION HOOKS
  # ============================================================================

  - id: pre-validation-check
    description: "Run pre-validation checks before spawning validator"
    event:
      type: on_validation
    actions:
      - type: log_message
        level: info
        message: "Starting validation for task ${task_id}"
    priority: 5
    enabled: true

  # ============================================================================
  # PROJECT CONTEXT SCANNER HOOKS
  # ============================================================================

  - id: validate-project-context-memory
    description: "Validate that project-context-scanner stored memory correctly and reinitialize if failed"
    event:
      type: post_complete
    conditions:
      - agent_type: project-context-scanner
        task_status: completed
    actions:
      - type: run_script
        script_path: ./.abathur/hooks/validate_project_context_memory.sh
        args: ["${task_id}"]
      - type: log_message
        level: info
        message: "Validating project context memory for task ${task_id}"
    priority: 10
    enabled: true

  # ============================================================================
  # CHILD SPAWNING HOOKS
  # ============================================================================

  - id: log-child-spawned
    description: "Log when child tasks are spawned"
    event:
      type: on_child_spawned
    actions:
      - type: log_message
        level: debug
        message: "Child task spawned by ${task_agent_type}: ${child_task_id}"
    priority: 1
    enabled: false  # Disabled by default - enable for debugging

  # ============================================================================
  # EXAMPLE: CUSTOM WORKFLOW HOOKS
  # ============================================================================
  # Uncomment and customize these examples for your workflows

  # - id: rust-build-validation
  #   description: "Validate Rust builds before marking ready"
  #   event: pre_ready
  #   conditions:
  #     - completed_agent_types_include:
  #         - rust-service-layer-specialist
  #         - rust-testing-specialist
  #   actions:
  #     - type: run_script
  #       script_path: ./hooks/rust_build_check.sh
  #       args: ["${worktree_path}"]
  #     - type: log_message
  #       level: info
  #       message: "Running Rust build validation"
  #   priority: 9
  #   enabled: false

  # - id: documentation-check
  #   description: "Ensure documentation exists before completion"
  #   event: pre_complete
  #   conditions:
  #     - agent_type: rust-service-layer-specialist
  #   actions:
  #     - type: run_script
  #       script_path: ./hooks/doc_check.sh
  #       args: ["${branch}"]
  #   priority: 5
  #   enabled: false
