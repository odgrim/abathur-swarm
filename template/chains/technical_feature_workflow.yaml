name: technical_feature_workflow
description: "Technical feature development workflow: requirements → architecture → technical specs → task planning → implementation → merge"

steps:
  - id: gather_requirements
    role: requirements-gatherer
    prompt: |
      Task: {task_description}
      Project Context: {project_context}

      Output the requirements analysis in JSON format:
      {
        "feature_name": "Short kebab-case name for this feature (e.g., user-authentication, payment-integration, api-rate-limiting)",
        "problem_statement": "Clear description of the problem to solve",
        "functional_requirements": [
          {"id": "FR-1", "description": "...", "priority": "must|should|could"}
        ],
        "non_functional_requirements": [
          {"id": "NFR-1", "category": "performance|security|scalability|...", "description": "...", "target": "specific metric"}
        ],
        "constraints": ["constraint1", "constraint2"],
        "success_criteria": ["criteria1", "criteria2"],
        "dependencies": ["existing_system1", "existing_system2"],
        "research_sources": [
          {"type": "codebase|web|memory", "reference": "file path or URL", "key_insight": "..."}
        ]
      }
    expected_output:
      type: json
      schema:
        type: object
        properties:
          feature_name:
            type: string
            description: "Short kebab-case name for the feature (used for branch naming)"
          problem_statement:
            type: string
          functional_requirements:
            type: array
            items:
              type: object
              properties:
                id:
                  type: string
                description:
                  type: string
                priority:
                  type: string
                  enum:
                    - must
                    - should
                    - could
              required:
                - id
                - description
                - priority
          non_functional_requirements:
            type: array
          constraints:
            type: array
          success_criteria:
            type: array
          dependencies:
            type: array
        required:
          - feature_name
          - problem_statement
          - functional_requirements
          - success_criteria
    post_hooks:
      # Store requirements in memory for future reference
      - type: run_script
        script_path: .abathur/scripts/store_requirements.sh
        args:
          - "${task_id}"
          - "requirements"
    next: design_architecture
    timeout_secs: 600

  - id: design_architecture
    role: technical-architect
    # Branch creation and task spawning handled by first-class decomposition config
    needs_branch: false
    # Decomposition config: fan-out pattern for subprojects
    decomposition:
      # Extract subprojects from output JSON - handles both single and multiple strategies
      # For single strategy, this will be a single-item array
      items_path: "$.decomposition.subprojects"
      per_item:
        branch:
          template: "feature/{feature_name}-{item}"
          parent: main
        task:
          agent_type: "technical-requirements-specialist"
          summary: "Create technical specs for {feature_name}/{item}"
          description: |
            Continue feature development workflow for subproject: {item}

            Architecture context from parent task:
            {previous_output}

            This is a decomposition child task - implement technical specifications
            for the {item} subproject following the architecture design.
          priority: 5
          continue_chain: true
          continue_at_step: create_technical_specs
      on_complete:
        wait_for_children: true
    prompt: |
      Requirements from previous step:
      {previous_output}

      Output the architecture design in JSON format:
      {
        "feature_name": "Short kebab-case name for this feature (e.g., user-authentication, payment-integration)",
        "architecture_overview": "High-level description",
        "components": [
          {
            "name": "component_name",
            "responsibility": "what it does",
            "interfaces": ["interface1", "interface2"],
            "dependencies": ["dep1", "dep2"]
          }
        ],
        "technology_stack": [
          {"layer": "frontend|backend|database|...", "technology": "...", "justification": "..."}
        ],
        "data_models": [
          {"entity": "User", "fields": ["id", "name", "email"], "relationships": ["has_many_posts"]}
        ],
        "api_contracts": [
          {"endpoint": "/api/users", "method": "POST", "request_schema": {}, "response_schema": {}}
        ],
        "decomposition": {
          "strategy": "single|multiple",
          "subprojects": ["project1", "project2"],
          "rationale": "why this decomposition"
        },
        "architectural_decisions": [
          {"decision": "...", "rationale": "...", "alternatives_considered": ["alt1", "alt2"]}
        ]
      }
    expected_output:
      type: json
      schema:
        type: object
        properties:
          feature_name:
            type: string
          architecture_overview:
            type: string
          components:
            type: array
          technology_stack:
            type: array
          decomposition:
            type: object
            properties:
              strategy:
                type: string
                enum:
                  - single
                  - multiple
            required:
              - strategy
        required:
          - feature_name
          - architecture_overview
          - components
          - decomposition
    post_hooks:
      # Store architecture in memory
      - type: run_script
        script_path: .abathur/scripts/store_architecture.sh
        args:
          - "${task_id}"
          - "architecture"
      - type: log_message
        level: info
        message: "Architecture designed for task ${task_id}"
    next: create_technical_specs
    timeout_secs: 600

  - id: create_technical_specs
    role: technical-requirements-specialist
    prompt: |
      Requirements: {gather_requirements.output}
      Architecture: {previous_output}

      IMPORTANT: The feature branch is named "feature/{feature_name}" and uses worktree at ".abathur/worktrees/feature-{feature_name}"

      Output the technical specifications in JSON format:
      {
        "components": [
          {
            "name": "component_name",
            "specifications": {
              "language": "Rust|Python|...",
              "framework": "...",
              "entry_point": "file_path",
              "key_modules": ["module1", "module2"]
            },
            "data_models": [
              {
                "name": "User",
                "fields": [
                  {"name": "id", "type": "UUID", "constraints": ["primary_key", "not_null"]},
                  {"name": "email", "type": "String", "constraints": ["unique", "not_null"]}
                ]
              }
            ],
            "apis": [
              {
                "endpoint": "/api/users",
                "method": "POST",
                "request": {"type": "object", "properties": {}},
                "response": {"type": "object", "properties": {}},
                "authentication": "required|optional|none"
              }
            ]
          }
        ],
        "implementation_phases": [
          {
            "phase": 1,
            "name": "Core Setup",
            "deliverables": ["deliverable1", "deliverable2"],
            "estimated_effort": "small|medium|large"
          }
        ],
        "testing_requirements": {
          "unit_tests": ["test_area1", "test_area2"],
          "integration_tests": ["scenario1", "scenario2"],
          "performance_targets": [
            {"metric": "response_time", "target": "< 200ms", "endpoint": "/api/users"}
          ]
        },
        "required_agents": [
          {
            "type": "rust-service-layer-specialist",
            "reason": "Implement async business logic",
            "estimated_tasks": 3
          }
        ]
      }
    expected_output:
      type: json
      schema:
        type: object
        properties:
          components:
            type: array
          implementation_phases:
            type: array
          testing_requirements:
            type: object
          required_agents:
            type: array
        required:
          - components
          - implementation_phases
          - required_agents
    post_hooks:
      # Store technical specs in memory
      - type: run_script
        script_path: .abathur/scripts/store_technical_specs.sh
        args:
          - "${task_id}"
          - "technical_specs"
      - type: log_message
        level: info
        message: "Technical specifications created for task ${task_id}"
    next: create_task_plan
    timeout_secs: 600

  - id: create_task_plan
    role: task-planner
    needs_branch: true
    branch_parent: "feature_branch"
    branch_name_template: "task/{feature_name}/{step_id}"
    working_directory: "{worktree_path}"
    prompt: |
      Technical Specs: {previous_output}

      IMPORTANT: Branch Strategy
      - Feature branch: "feature/{feature_name}"
      - You are working in task branch: "task/{feature_name}/planning"
      - ALL implementation tasks will inherit YOUR task branch and worktree
      - All implementation work happens in the SAME branch you're in
      - When all tasks complete, this single task branch merges into the feature branch

      Output the task plan in JSON format:
      {
        "tasks": [
          {
            "id": "implement-user-model",
            "summary": "Implement User domain model",
            "description": "Create User struct with validation logic...",
            "agent_type": "rust-domain-models-specialist",
            "phase": 1,
            "estimated_effort": "small|medium|large",
            "dependencies": [],
            "deliverables": [
              {"type": "code", "path": "src/domain/models/user.rs"},
              {"type": "test", "path": "tests/unit/user_tests.rs"}
            ],
            "validation_criteria": [
              "All fields properly typed and validated",
              "Unit tests achieve >90% coverage",
              "Follows domain model patterns"
            ],
            "needs_worktree": true
          }
        ],
        "execution_order": [
          {"batch": 1, "tasks": ["task-001", "task-002"], "can_parallelize": true},
          {"batch": 2, "tasks": ["task-003"], "can_parallelize": false}
        ],
        "agent_workload": [
          {
            "agent_type": "rust-domain-models-specialist",
            "task_count": 3,
            "total_effort": "medium"
          }
        ],
        "estimated_total_duration": "2-3 hours",
        "critical_path": ["task-001", "task-005", "task-008"]
      }
    expected_output:
      type: json
      schema:
        type: object
        properties:
          tasks:
            type: array
            items:
              type: object
              properties:
                id:
                  type: string
                summary:
                  type: string
                description:
                  type: string
                agent_type:
                  type: string
                dependencies:
                  type: array
                deliverables:
                  type: array
                validation_criteria:
                  type: array
                needs_worktree:
                  type: boolean
              required:
                - id
                - summary
                - description
                - agent_type
                - deliverables
          execution_order:
            type: array
    post_hooks:
      # Spawn implementation tasks via task queue
      - type: run_script
        script_path: .abathur/scripts/spawn_implementation_tasks.sh
        args:
          - "${task_id}"
          - "tasks_json"
      - type: log_message
        level: info
        message: "Created implementation tasks for execution"
    next: prepare_merge
    timeout_secs: 420

  - id: prepare_merge
    role: git-worktree-merge-orchestrator
    prompt: |
      Implementation Status: {previous_output}

      Output the merge readiness assessment in JSON format:
      {
        "ready_to_merge": true,
        "verification_results": {
          "all_tasks_complete": true,
          "tests_passing": true,
          "quality_checks_passed": true,
          "no_conflicts": true,
          "documentation_complete": true
        },
        "test_summary": {
          "unit_tests": {"total": 45, "passed": 45, "failed": 0},
          "integration_tests": {"total": 12, "passed": 12, "failed": 0},
          "coverage_percentage": 92
        },
        "branches_to_merge": [
          {"source": "task/001-user-model", "target": "feature/{task_id}"},
          {"source": "task/002-user-service", "target": "feature/{task_id}"}
        ],
        "final_deliverables": [
          {"type": "code", "count": 15, "loc": 2340},
          {"type": "tests", "count": 57, "coverage": "92%"},
          {"type": "docs", "count": 8}
        ],
        "merge_strategy": "rebase",
        "post_merge_actions": ["cleanup_worktrees", "tag_release"]
      }
    expected_output:
      type: json
      schema:
        type: object
        properties:
          ready_to_merge:
            type: boolean
          verification_results:
            type: object
          branches_to_merge:
            type: array
        required:
          - ready_to_merge
          - verification_results
          - branches_to_merge
    pre_hooks:
      # Run comprehensive test suite
      - type: run_script
        script_path: scripts/run_all_tests.sh
        args:
          - "${task_id}"
      # Run quality checks
      - type: run_script
        script_path: scripts/quality_checks.sh
        args:
          - "${task_id}"
    post_hooks:
      # Merge all task branches to feature branch
      - type: run_script
        script_path: .abathur/scripts/merge_branches.sh
        args:
          - "${task_id}"
          - "branches_json"
      # Clean up all worktrees and branches
      - type: run_script
        script_path: .abathur/scripts/cleanup_all_worktrees.sh
        args:
          - "${task_id}"
      - type: log_message
        level: info
        message: "Successfully completed full workflow for task ${task_id}"
    timeout_secs: 300

validation_rules:
  - step_id: gather_requirements
    rule_type:
      type: json_schema
    error_message: "Requirements must include problem statement, functional requirements, and success criteria"

  - step_id: design_architecture
    rule_type:
      type: json_schema
    error_message: "Architecture must specify components and decomposition strategy"

  - step_id: create_technical_specs
    rule_type:
      type: json_schema
    error_message: "Technical specs must include components, phases, and required agents"

  - step_id: create_task_plan
    rule_type:
      type: json_schema
    error_message: "Task plan must include tasks array with agent assignments and execution order"

  - step_id: prepare_merge
    rule_type:
      type: custom_validator
      name: merge_readiness
    error_message: "Cannot merge - not all verification checks passed"
